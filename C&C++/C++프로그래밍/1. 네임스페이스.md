# C++ 네임스페이스(namespace)의 필요성과 활용

---

## 개요

C++에서 네임스페이스(namespace)는 변수, 함수, 구조체 등의 이름 충돌을 방지하기 위한 문법이다.  
대규모 프로젝트에서 각 모듈 간의 충돌 없이 독립적인 이름 공간을 구성할 수 있어 코드 관리에 매우 유리하다.

---

## C 언어에서 발생할 수 있는 이름 충돌 문제

### 예시: 함수명이 겹치는 상황

```c
#include <stdio.h>

void init(void) {
	printf("init BTS Audio Module\n");
}

void init(void) {
	printf("init EXO Video Module\n");
}

int main(void) {
	init(); // 컴파일 에러: 함수 중복 정의
	return 0;
}
````

* C 언어에서는 동일한 이름의 함수를 두 번 정의할 수 없다.
* 여러 모듈이 동일한 함수명이나 변수명을 사용할 경우 충돌이 발생한다.

---

## C 언어에서의 해결책: 함수 이름 구분

```c
void audio_init() { ... }
void video_init() { ... }
```

* 이런 식으로 prefix를 붙여 해결할 수 있지만, 협업 시 이름을 일일이 조율해야 하므로 비효율적이다.

---

## C++에서의 해결책: 네임스페이스 사용

```cpp
#include <stdio.h>

namespace Audio {
	void init() {
		printf("init Audio Module\n");
	}
}

namespace Video {
	void init() {
		printf("init Video Module\n");
	}
}

int main() {
	Audio::init(); // OK
	Video::init(); // OK
	return 0;
}
```

* 동일한 `init()` 함수 이름을 네임스페이스로 구분하여 사용할 수 있다.
* `Audio::init()`, `Video::init()`처럼 호출 시 명확하게 구분된다.

---

## 네임스페이스의 장점

* 변수명, 함수명이 충돌하지 않도록 안전하게 구분 가능
* 코드 모듈화, 분리 및 유지보수가 쉬워짐
* 외부 라이브러리나 협업 개발 환경에서도 안정적인 통합 가능

---

## 네임스페이스 관련 문법

```cpp
namespace MyModule {
	int count = 0;
	void print();
	struct Data { int x; };
}
```

### using 선언으로 간편하게 접근

```cpp
using namespace MyModule;

int main() {
	print(); // MyModule::print()와 동일하게 동작
}
```

* 단, 전역 충돌 가능성이 있으므로 사용하는 위치에 유의해야 한다.

---

## 결론

* C++의 네임스페이스는 이름 충돌을 방지하기 위한 필수 개념이다.
* 특히 대규모 프로젝트나 라이브러리 통합 시 유용하다.
* C에서는 네임스페이스가 없기 때문에 명시적 네이밍 규칙을 사용하는 방식으로 우회해야 한다.

---

# 네임스페이스 접근 방법: 3가지 방식

---

## 개요

C++에서 네임스페이스 내부의 요소(함수, 변수 등)에 접근하는 방법은 총 3가지가 있다.  
각 방법은 코드의 명확성, 편의성, 범위 통제에 차이가 있으므로 목적에 따라 적절히 선택해야 한다.

---

## 세 가지 접근 방식 요약

| 방법 | 설명 | 예시 |
|------|------|------|
| qualified name | 완전한 이름을 사용하는 방법 | `Audio::init()` |
| using declaration | 특정 항목만 가져오는 방식 | `using Video::init;` |
| using directive | 전체 네임스페이스를 가져오는 방식 | `using namespace Video;` |

---

## 예제 코드

```cpp
#include <iostream>

namespace Audio {
	void init() {
		std::cout << "init BTS Audio Module\n";
	}
	void stop() {
		std::cout << "stop BTS Audio Module\n";
	}
}

namespace Video {
	void init() {
		std::cout << "init EXO Video Module\n";
	}
	void stop() {
		std::cout << "stop EXO Video Module\n";
	}
	void play() {
		std::cout << "play EXO Video Module\n";
	}
}

int main() {
	// (1) qualified name
	Audio::init();
	Video::init();
	Video::stop();
	Video::play();

	std::cout << std::endl;

	// (2) using declaration
	using Video::init;
	using Video::stop;

	init();  // Video::init()
	stop();  // Video::stop()

	std::cout << std::endl;

	// (3) using directive
	using namespace Video;

	init();  // Video::init()
	stop();  // Video::stop()
	play();  // Video::play()

	return 0;
}
````

---

## 각 방법의 특징 및 문제점

### 1. qualified name (권장)

* 가장 명확하고 충돌 우려가 없다.
* 단점: 코드가 길어지고 반복된다.
* 예시: `Video::init();`

### 2. using declaration (선택적 사용 가능)

* 특정 항목만 네임스페이스에서 가져온다.
* 여러 using 선언이 섞이면 오히려 혼란을 줄 수 있다.
* 예시:

```cpp
using Video::init;
using Audio::init; // 이후 init() 호출은 ambiguous
```

### 3. using directive (지양)

* 네임스페이스 전체를 현재 범위로 끌어온다.
* 가장 편리해 보이지만 **이름 충돌 위험**이 매우 높다.
* 특히 `using namespace std;`처럼 전체를 가져오는 경우는 규모가 커질수록 위험하다.

---

## 결론

* 가능한 한 **qualified name** 방식으로 명시적으로 사용할 것
* `using declaration`은 제한적으로 사용할 것 (특정 함수만 쓸 때)
* `using directive`는 **지양할 것**, 특히 전역에서의 사용은 피해야 함

### 예시: 권장 방식

```cpp
// 명시적으로 사용
Audio::init();
Video::play();

// 제한적으로 using 사용
using std::cout;
using std::endl;
```

* 네임스페이스는 이름 충돌을 방지하기 위한 도구이며,
  using을 남용하면 본래 목적을 해치는 결과가 된다.

---