# 객체 지향 설계 원칙: SOLID

---

## 개요

SOLID는 객체 지향 프로그래밍에서 **유지보수성**, **확장성**, **재사용성**을 높이기 위한 다섯 가지 핵심 설계 원칙이다.  
이 원칙을 따름으로써 변경에 강하고, 유연한 소프트웨어 아키텍처를 설계할 수 있다.

---

## SOLID 원칙 요약

### 1. SRP — 단일 책임 원칙 (Single Responsibility Principle)

- **정의**: 클래스는 단 하나의 책임만 가져야 한다.
- **의도**: 변경 사유가 하나뿐이어야 하며, 여러 책임이 하나의 클래스에 있으면 결합도가 증가하고 유지보수가 어려워진다.
- **예시**: 출력 로직과 데이터 저장 로직을 분리하여 책임을 나눈다.

### 2. OCP — 개방-폐쇄 원칙 (Open-Closed Principle)

- **정의**: 클래스는 **확장에는 열려 있고**, **수정에는 닫혀 있어야 한다**.
- **의도**: 기존 코드를 수정하지 않고 기능을 확장할 수 있도록 설계한다.
- **방법**: 다형성, 추상 클래스, 인터페이스 등을 활용하여 새로운 기능을 기존 구조에 영향을 주지 않고 추가한다.

### 3. LSP — 리스코프 치환 원칙 (Liskov Substitution Principle)

- **정의**: 부모 타입의 객체를 자식 타입 객체로 대체해도 프로그램이 정상적으로 동작해야 한다.
- **의도**: 자식 클래스는 부모 클래스의 행위를 **완전히 대체할 수 있어야** 한다.
- **위반 예시**: 오버라이딩된 메서드가 부모의 계약(contract)을 깨트릴 경우

### 4. ISP — 인터페이스 분리 원칙 (Interface Segregation Principle)

- **정의**: **범용 인터페이스 하나**보다, **구체적인 인터페이스 여러 개**가 낫다.
- **의도**: 클라이언트가 사용하지 않는 메서드에 의존하지 않도록 인터페이스를 분리한다.
- **결과**: 인터페이스를 구현하는 클래스가 필요 없는 메서드를 강제로 구현하지 않게 됨

### 5. DIP — 의존 역전 원칙 (Dependency Inversion Principle)

- **정의**: **상위 모듈은 하위 모듈에 의존하면 안 되고**, 둘 다 **추상화에 의존해야 한다**.
- **의도**: 구체적인 구현이 아니라, 인터페이스나 추상 클래스에 의존하도록 설계
- **효과**: 모듈 간 결합도를 낮추고 유연한 설계를 가능하게 함

---

## 정리

| 원칙 | 이름 | 핵심 내용 |
|------|------|-----------|
| SRP | 단일 책임 원칙 | 하나의 클래스는 하나의 책임만 |
| OCP | 개방-폐쇄 원칙 | 확장에는 열려 있고, 수정에는 닫혀 있어야 함 |
| LSP | 리스코프 치환 원칙 | 자식은 부모를 대체할 수 있어야 함 |
| ISP | 인터페이스 분리 원칙 | 작은 인터페이스 여러 개가 낫다 |
| DIP | 의존 역전 원칙 | 구현이 아닌 추상화에 의존해야 한다 |

- SOLID 원칙은 **객체 지향 설계의 핵심 철학**을 담고 있으며,  
  유지보수가 용이하고 확장 가능한 코드를 작성하기 위한 기준이 된다.