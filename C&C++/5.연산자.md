# 01. C의 연산자 개요

---

## 목표

- C의 주요 연산자와 우선순위를 학습하고, 코딩 실수 방지에 도움을 준다.

---

## 연산자란?

- 변수나 값에 연산을 수행하는 기호 또는 키워드.

---

## 연산자 종류

| 분류        | 연산자                          | 설명          |
|--------------|----------------------------------|----------------|
| 산술 연산자  | + - * / %                       | 사칙 연산      |
| 대입 연산자  | = += -= *= /= %= <<= >>= &= ^=  | 대입 및 복합 대입 |
| 부호 연산자  | + -                              | 양수/음수 부호  |
| 증감 연산자  | ++ --                            | 1씩 증가/감소   |
| 관계 연산자  | == != < > <= >=                  | 비교 연산      |
| 논리 연산자  | && \|\| !                        | 논리 연산      |
| 비트 연산자  | & \| ^ ~ << >>                   | 비트 연산      |
| 삼항 연산자  | ? :                              | 조건식         |
| 콤마 연산자  | ,                                | 여러 식 순차적 실행 |
| 포인터/참조  | * &                              | 역참조, 주소 연산 |
| 멤버 접근    | . ->                             | 구조체 멤버 접근  |
| 기타 연산자  | sizeof, (type)                   | 크기, 형변환   |
| 배열/함수    | [] ()                            | 배열 인덱스, 함수 호출 |

---

## 연산자 우선순위

예시:

```c
int r = 1 + 2 * 3;  // 결과: 7
````

* * 연산자가 +보다 우선순위 높음 → 2 \* 3 먼저 계산.

---

### 우선순위 헷갈리면?

* 괄호 ()로 감싸서 명확하게 표현.

```c
r = (1 + 2) * 3;  // 결과: 9
```

---

### 외워야 할 주요 우선순위

* 가장 높음: `() [] . ->`
* 그다음: 단항 연산자 `++ -- + - * &`
* 비트 연산자: 낮은 편
* 가장 낮음: 대입 연산자 `=`

---

### 중요 예제

```c
*(parr + 1) = 123;    // parr[1] = 123;
*(parr)++ = 123;      // *(parr) 먼저 처리, 이후 parr 증가
```

---

## 결합 방향 (Associativity)

* 대입 연산자: 오른쪽 → 왼쪽

  ```c
  a = b = c = 5;  // c = 5 먼저 수행
  ```
* 산술 연산자: 왼쪽 → 오른쪽

  ```c
  int r = 2 + 3 + 4;  // 왼쪽부터 계산
  ```

---

## 단항, 이항, 삼항 연산자

| 종류 | 설명      | 예시        |
| -- | ------- | --------- |
| 단항 | 피연산자 1개 | ++a, -a   |
| 이항 | 피연산자 2개 | a + b     |
| 삼항 | 피연산자 3개 | a ? b : c |

---

# sizeof() 연산자

---

## 목표

- sizeof 연산자의 사용법과 주의할 점을 학습한다.

---

## sizeof 연산자란?

- 데이터 타입 또는 변수의 **바이트 크기**를 구하는 연산자.
- 함수처럼 보이지만, **연산자**임.

예시:

```c
#include <stdio.h>

int main() {
    char a = 'a';
    int b = 123;
    float c = 3.141;
    double d = 2.718;

    printf("a size is %zu\n", sizeof(a));
    printf("b size is %zu\n", sizeof(b));
    printf("c size is %zu\n", sizeof(c));
    printf("d size is %zu\n", sizeof(d));

    return 0;
}
````

---

## 형 vs 참조

```c
sizeof(student_t) // 구조체 크기 반환
sizeof(s1)        // 변수 s1의 타입 크기 반환 (student_t와 동일)
```

* 형(type)이나 변수 참조 모두 사용 가능.

---

## sizeof 특징

* **컴파일 시점**에 계산된다 (실행시간에 부하 없음).
* 배열 요소 수 계산, 구조체 패딩 확인 등에 유용하다.

---

## 구조체 패딩 예제

```c
#include <stdio.h>

typedef struct _foo_t {
    char a;
    char b;
    char c;
    char d;
    char e;
    int f;
    double g;
} foo_t;

int main() {
    foo_t foo;
    printf("%zu\n", sizeof(foo)); // 예상보다 큰 값 (예: 24)
    return 0;
}
```

* 구조체 패딩으로 인해 메모리 정렬이 발생.
* 멤버 순서를 조정해 패딩을 줄일 수 있다.

---

## 배열과 sizeof

```c
#include <stdio.h>

int arr[3][2] = {
    {11, 22},
    {33, 44},
    {55, 66},
};

int main() {
    printf("%zu\n", sizeof(arr));        // 전체 크기: 3 * 2 * 4 = 24 (int = 4바이트 기준)
    printf("%zu\n", sizeof(arr[0]));      // 첫 번째 행 크기: 2 * 4 = 8
    printf("%zu\n", sizeof(arr[0][0]));   // int 크기: 4
}
```

---

## 주의사항: 출력 시 %zu 사용

* sizeof 결과는 `size_t` (부호 없는 정수) 반환.
* `%d` 대신 `%zu`를 사용해야 경고 없이 정확하게 출력 가능.

```c
printf("%zu\n", sizeof(int));  // 올바른 출력
```

---

# 비트 연산자 (Bit Operator)

---

## 목적

- C언어의 비트 연산자를 학습하고, 실습을 통해 빠르게 이해한다.

---

## 비트 연산자 종류

| No. | 연산 | 연산자 | 기능                |
|-----|------|--------|---------------------|
| 1   | AND  | &      | 비트 단위 AND 연산  |
| 2   | OR   | \|     | 비트 단위 OR 연산   |
| 3   | NOT  | ~      | 비트 반전 (NOT)     |
| 4   | XOR  | ^      | 비트 단위 XOR 연산  |
| 5   | LEFT SHIFT  | << | 왼쪽으로 비트 이동 |
| 6   | RIGHT SHIFT | >> | 오른쪽으로 비트 이동 |

---

## 비트 연산자 실습 #1

```c
#include <stdio.h>

int main() {
    unsigned int a = 0b1001; // 9
    unsigned int b = 0b1011; // 11

    printf("(1) a & b  = %3d\n", a & b);
    printf("(2) a | b  = %3d\n", a | b);
    printf("(3) ~a     = %3d\n", ~a);
    printf("(4) a ^ b  = %3d\n", a ^ b);
    printf("(5) a << 1 = %3d\n", a << 1);
    printf("(6) a >> 1 = %3d\n", a >> 1);

    return 0;
}
````

* \~ 연산자는 모든 비트를 반전, 부호 비트도 반전된다.
* Left Shift (<<): 값 \* 2^n
* Right Shift (>>): 값 / 2^n

---

## 비트 연산자 실습 #2

```c
#include <stdio.h>

int main() {
    unsigned int a = 15; // 0b01111
    unsigned int b = 20; // 0b10100

    printf("(1) a & b  = %3d\n", a & b);  // 4
    printf("(2) a | b  = %3d\n", a | b);  // 31
    printf("(3) ~a     = %3d\n", ~a);     // -16 (MSB 반전으로 음수)
    printf("(4) a ^ b  = %3d\n", a ^ b);  // 27
    printf("(5) a << 1 = %3d\n", a << 1); // 30
    printf("(6) a >> 1 = %3d\n", a >> 1); // 7

    return 0;
}
```

* Left Shift는 빠른 곱셈, Right Shift는 빠른 나눗셈으로 사용 가능.
* 단, 곱하기/나누기가 반드시 2의 배수여야 함.

---

* 비트 연산자는 임베디드, 하드웨어 제어, 플래그 처리에서 매우 유용하다.

---