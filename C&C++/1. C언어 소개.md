# 1. C 언어 소개

## 역사와 배경
- 1972년 벨 연구소의 데니스 리치와 켄 톰슨이 개발
- UNIX 운영체제를 위한 고급 언어로 설계
- BCPL에서 발전한 B언어를 개선하여 만듦
- DEC사의 PDP-11에 최초 탑재

## 등장 배경과 필요성
- **당시 하드웨어를 강력하게 제어할 수 있는 운영체제가 절실히 필요**
- 기존 어셈블리어의 한계:
  1. 하드웨어 의존도가 매우 높음
  2. 인간보다 컴퓨터에 맞춰진 설계

## C 언어의 주요 특징
1. 하드웨어 의존도 낮음
   - 하드웨어가 변경되어도 코드 재작성 최소화
2. 강력한 하드웨어 제어 능력
3. 인간 친화적인 표현 가능

## 적용 분야
- Unix/Linux
- 임베디드 시스템
- 컴퓨터 게임
- 로봇 자동화
- PC 어플리케이션

## 현대적 의의
- 다른 과거 언어들(COBOL, FORTRAN 등)과 달리 현재까지 널리 사용
- 임베디드 시스템에서는 C++보다 더 선호됨
- C++은 C에 객체지향 개념을 추가한 언어

## 특이사항
- 프로그래머를 위한 도구로 개발된 점이 특징
- 다른 언어들의 목적:
  - Pascal: 프로그래밍 교육
  - COBOL: 상업용
  - Fortran: 과학용
  - EPL: 어린이 교육용

<br>

# 2. C 언어 키워드

## 키워드란?  
- C 컴파일러가 특별한 의미를 부여한 예약어 (Reserved Word).  
- 변수명, 함수명으로 사용 불가.  

```c
int int; // Error: int는 변수명으로 사용 불가
void struct(int a, int b); // Error: struct는 함수명으로 사용 불가
````

---

## C 언어 키워드 (32개)

| 키워드    | 설명                   |
| -------- | -------------------- |
| auto     | 지역 변수 저장 클래스 (자동 저장) |
| break    | 반복문/스위치문 즉시 종료       |
| case     | switch문의 분기 지정       |
| char     | 문자형 데이터 타입           |
| const    | 상수 선언 (값 변경 불가)      |
| continue | 반복문 다음 반복으로 이동       |
| default  | switch문 기본 분기        |
| do       | do-while 반복문 시작      |
| double   | 배정밀도 실수형             |
| else     | if문 조건 거짓일 때 실행      |
| enum     | 열거형 사용자 정의 타입        |
| extern   | 외부 변수/함수 선언          |
| float    | 단정밀도 실수형             |
| for      | for 반복문              |
| goto     | 코드 흐름 이동 (권장X)       |
| if       | 조건문                  |
| int      | 정수형 데이터 타입           |
| long     | 긴 정수형                |
| register | 레지스터 저장 클래스 (권장X)    |
| return   | 함수 종료 및 값 반환         |
| short    | 짧은 정수형               |
| signed   | 부호 있는 정수형 지정         |
| sizeof   | 데이터 크기 반환 (바이트)      |
| static   | 정적 저장 클래스            |
| struct   | 구조체 사용자 정의 타입        |
| switch   | 다중 분기 조건문            |
| typedef  | 데이터 타입 별칭            |
| union    | 여러 타입을 한 메모리에 저장     |
| unsigned | 부호 없는 정수형 지정         |
| void     | 반환값 없음, 포인터 미지정      |
| volatile | 외부에서 값 변경 가능 알림      |
| while    | while 반복문            |

---

## volatile 키워드

* 변수 값이 예측 불가능하게 변경될 수 있음을 컴파일러에 알림.
* 사용 사례:

  * 하드웨어 레지스터 접근
  * 인터럽트 서비스 루틴 (ISR)
  * 멀티스레딩 환경

```c
volatile bool interrupt_flag = false;

void ISR() {
    interrupt_flag = true;
}

int main() {
    while (!interrupt_flag) { /* Wait for interrupt */ }
    printf("Interrupt occurred!\n");
    return 0;
}
```

* volatile 없으면 컴파일러가 interrupt\_flag를 캐시하고 무한 루프 발생 가능.

<br>

# 3. C언어 프로그램 구조  

## 프로그램 구조란?  
- C언어 프로그램은 전처리기, 전역 데이터, 함수로 구성됨.  
- 함수는 블록(Block), 블록은 문장(Statement)으로 세분화됨.  
- 문장은 선언문, 대입문, 함수 호출문, 제어문, NULL문 등으로 구분.  
- 주요 구성 요소: 주석(Comments), 상수(Constant), 예약어(Reserved Word), 식별자(Identifier).  

---

## 프로그램 실행 흐름  

- 프로그램의 시작점은 `main` 함수 (Entry Point).  
- 운영체제가 가장 먼저 호출하는 함수.  

```c
#include <stdio.h>

int main(void) {
    printf("Hello, World !!");
}
````


## 퀴즈

### Q. 아래 코드는 왜 잘못된 것일까?

```c
void main(void) {}
```

**답안:**

* C언어 표준(ISO C 표준)에서는 `main` 함수의 반환형은 반드시 `int`여야 한다.
* `void main(void)`는 컴파일러에 따라 동작할 수 있지만, 표준을 따르지 않는 잘못된 코드이다.
* 올바른 작성:

```c
int main(void) {
    return 0;
}
```

<br>

# 4. C언어 표준의 중요성  

## 퀴즈 (Quiz)  

### Q1. 어떤 코드가 더 좋은가? (헤더 가드)  

```cpp
#pragma once
// Your code here...
````

```cpp
#ifndef __FILE_NAME_H__
#define __FILE_NAME_H__

// Your code here...

#endif
```

답안:

* (2)번이 더 좋다.
* 이유:

  * `#pragma once`는 MSVC 전용 확장이며, 표준이 아니다.
  * `#ifndef` 방식은 C 표준에서 정의된 방식으로, 모든 컴파일러에서 동작한다.
  * 표준을 지켜야 코드 이식성이 높아진다.

---

### Q2. 어떤 코드가 더 좋은가? (헤더 파일 포함 여부)

```cpp
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <time.h>

int main() {
    printf("Hello, world!\n");
    double result = sqrt(4.0);
    printf("The square root of 4 is %f\n", result);
    return 0;
}
```

```cpp
#include <stdio.h>

int main() {
    printf("Hello, world!\n");
    double result = sqrt(4.0); // <math.h>를 포함하지 않음
    printf("The square root of 4 is %f\n", result);
    return 0;
}
```

답안:

* 첫 번째 코드가 더 좋다.
* 이유:

  * 필요한 헤더 `<math.h>`를 명확히 포함하여 표준을 준수했다.
  * 두 번째 코드는 표준 위반으로 컴파일러마다 동작이 다를 수 있다.

---

## C언어 표준의 중요성

* 표준을 지키면 코드를 다양한 환경에 이식하고, 유지보수성과 신뢰성을 높일 수 있다.
* 코드 규모가 커질수록 표준 준수 여부에 따른 문제가 크게 발생한다.

### 표준 준수 이유

1. 이식성 향상 (Portability)

   * 다양한 컴파일러, 플랫폼에서 코드 재사용 가능.

2. 코드 신뢰성 향상 (Reliability)

   * 표준 준수 시 문법, 동작 방식, 라이브러리가 명확하게 정의되어 버그 발생 감소.

3. 프로그램 품질 향상 (Quality)

   * 정의되지 않은 동작(Undefined Behavior) 방지.
   * 안정성과 보안성 향상 (특히 임베디드, MISRA-C 등에서 중요).

---

## 표준 준수 사례 vs 비표준 사례

### 1. 매크로 정의 시 괄호 사용

올바른 예

```cpp
#define SQUARE(x) ((x) * (x))
```

잘못된 예

```cpp
#define SQUARE(x) x * x
```

---

### 2. 명확한 형 변환

올바른 예

```cpp
unsigned int u = 10;
int s = -5;
u = (unsigned int)s; // 명시적 형변환
```

잘못된 예

```cpp
unsigned int u = 10;
int s = -5;
u = s; // 암묵적 형변환
```

---

결론:

* 표준을 잘 지킨 코드는 이식성, 신뢰성, 유지보수성이 높고, 협업에 유리하다.
* 비표준 코드 사용 시 컴파일러 의존성 증가, 버그 발생, 품질 저하 위험이 크다.
* 따라서, 처음부터 표준을 철저히 준수하는 습관을 들이는 것이 매우 중요하다.

# C 언어 표준 요약

---

## C 언어 표준 발전 순서

| 연도   | 명칭      | 공식 표준명            | 주요 특징                                               |
| ---- | ------- | ----------------- | --------------------------------------------------- |
| 1972 | 최초 개발   | -                 | C 언어 최초 개발, 표준 없음                                   |
| 1978 | K\&R C  | -                 | 첫 비공식 표준, K\&R 책 기반                                 |
| 1989 | C89     | ANSI X3.159-1989  | 첫 공식 표준, 함수 프로토타입, void 도입                          |
| 1990 | C90     | ISO/IEC 9899:1990 | C89와 동일, ANSI 표준의 국제화                               |
| 1999 | C99     | ISO/IEC 9899:1999 | // 주석, long long int, VLA, bool, inline 등 현대적 기능 도입 |
| 2011 | C11     | ISO/IEC 9899:2011 | 멀티스레딩, 원자 연산, Unicode 개선, static\_assert 등 도입       |
| 2018 | C17/C18 | ISO/IEC 9899:2018 | 버그 수정 및 명확화 (신기능 없음)                                |
| 2024 | C23     | ISO/IEC 9899:2024 | 최신 표준, typeof, 라이브러리 확장, 현대적 기능 강화                  |

---

## 주요 변화 요약

* **K\&R C (1978)**: 최초의 C 언어 문서화, 공식 표준 아님, 라이브러리 정의 없음.
* **C89/C90**: 현대 C의 기초 마련, 프로토타입과 void 타입 도입, 코드 이식성 향상.
* **C99**: 현대적 기능 대거 추가 (한 줄 주석, VLA, bool, 복합 리터럴), 과학·공학 계산 지원.
* **C11**: 멀티스레딩, 원자 연산, Unicode 강화, 컴파일 시간 검증 도구 추가.
* **C17/C18**: 주로 버그 수정 및 명확화, 실질적 기능 변화 없음.
* **C23**: 최신 표준, 현대 프로그래밍 환경에 맞춘 다양한 기능 추가.

---

## 질문 코드 관련 설명

```c
#include <stdio.h>

int main(void) {
    printf("Hello, World !!");  // (1)
    int age = 38;               // (2) C99 이전에는 오류 발생
    return 0;
}
```

* C99 이전 표준(C89, C90)에서는 \*\*(1)\*\*과 같은 실행 문장 이후에 **변수 선언**이 오면 컴파일 에러 발생.
* C99부터는 중간에 변수 선언이 허용됨.

---

# 09. 왜 C언어인가? (Why C?)

---

## 목표

- 여러 프로그래밍 언어 중 왜 C언어를 사용할까?
- 앞으로도 C언어가 계속 사용될까?

---

## 왜 C언어를 배워야 하나?

- C언어는 하드웨어 제어에 필수적이다.
- 사용 언어는 프로젝트 목적에 따라 결정해야 한다.
- C언어를 모르면 로봇, 임베디드, 하드웨어 제어가 어렵다.

---

## 예전의 프로그래밍 언어

- 1970년대 다양한 언어 등장: C, Fortran, COBOL, BASIC
- 대부분 사장되었으나 C는 여전히 사용됨.
- BASIC은 교육용으로 시작했으나 현재는 거의 사용되지 않음.
- Fortran, COBOL 등도 현재는 거의 사용되지 않는다.

---

## 근래의 프로그래밍 언어

- Java: 1991년 등장, 빠르게 1위로 부상.
- Python: 최근 인기가 급상승, 현대 컴퓨팅 환경에 최적화.
- Kotlin: Java 대체 언어로 부상.
- JavaScript: 필수 웹 언어로 자리잡음.

---

## C는 예외적인 언어

- Fortran, COBOL은 사장됐지만 C는 여전히 강력한 영향력 유지.
- C/C++은 시장의 필요성으로 현재까지도 사용됨.

---

## C언어의 장단점

- 장점: 하드웨어 직접 제어, 저수준 메모리 접근 가능.
- 단점: 메모리 관리의 어려움, 포인터 사용으로 인한 복잡성.
- 최신 언어들은 메모리 관리가 추상화되어 있다.

---

## C언어를 잘하려면

1. 기본 문법 정확히 이해  
    예시 코드:
    ```c
    int a = 11;
    int b = 22;
    int r = a + b;
    ```

2. 시스템 전반에 대한 이해  
    - 메모리, CPU 동작, 힙/스택, 엔디안, 구조체 패딩, 동적할당 등을 이해해야 한다.

- 공학은 논리적이므로 꾸준히 학습하면 실력 향상이 가능하다.

---

## 결론 및 C언어의 미래

- C언어는 임베디드, 하드웨어 제어 분야에서 독보적이다.
- AUTOSAR 표준도 C를 지원하고 있다.
- 앞으로도 주요 언어로 계속 사용될 가능성이 높다.

---

C언어는 50년이 넘도록 유지된 유일한 프로그래밍 언어 중 하나로, 성능, 기계적 호환성, 보편성 측면에서 여전히 강력한 경쟁력을 갖고 있다.

