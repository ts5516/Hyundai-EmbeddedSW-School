# 컴파일(Compile)에 대한 이해

---

## 서론

프로그래밍을 하면서 소스 코드를 작성하고 실행하기 위해 "빌드(Build)" 또는 "컴파일(Compile)"을 해본 경험이 많을 것이다.  
하지만 컴파일이 정확히 어떤 과정을 거쳐, 어떤 결과물을 만드는지에 대해 깊이 이해하고 있는 사람은 많지 않다.  

이번 기회에 컴파일이 무엇인지, 컴파일 과정은 어떻게 진행되는지, 그리고 그 과정에서 어떤 도구와 개념이 사용되는지 알아보자.

---

## 컴파일의 정의

- **컴파일(Compile)**: 사람이 작성한 고수준 언어(C, C++, Java 등)의 소스 코드를, CPU가 이해할 수 있는 저수준 언어(기계어)로 변환하는 과정.
- 컴퓨터는 오직 0과 1로 구성된 **기계어(Machine Code)**만 이해할 수 있기 때문에, 우리가 작성한 코드를 실행하기 위해서는 이 과정을 반드시 거쳐야 한다.
- 컴파일 결과로 생성되는 실행 파일은 운영체제의 **로더(Loader)**에 의해 메모리에 적재되고 실행된다.

---

## 컴파일 과정 (4단계)

컴파일 과정은 다음과 같은 네 가지 단계로 나뉜다.

### 1. 전처리 (Pre-processing)

- **입력 파일**: 소스 코드 파일 (*.c)
- **출력 파일**: 전처리된 소스 코드 (*.i)
- **도구**: 전처리기 (Preprocessor)

#### 주요 작업
- **주석 제거**:  
  코드의 주석은 컴퓨터가 이해할 필요가 없으므로 모두 삭제된다.
- **헤더 파일 처리**:  
  `#include` 지시문을 만나면 해당 헤더 파일 내용을 그대로 소스 코드에 복사한다.
- **매크로 치환**:  
  `#define`으로 정의된 매크로를 찾아 해당 값으로 모두 치환한다.

> 예시  
```c
#include <stdio.h>
#define PI 3.14

int main() {
    printf("%f\n", PI);
}
````

전처리 후에는 아래처럼 변환된다.

```c
int main() {
    printf("%f\n", 3.14);
}
```

---

### 2. 컴파일 (Compilation)

* **입력 파일**: 전처리된 파일 (\*.i)
* **출력 파일**: 어셈블리어 파일 (\*.s)
* **도구**: 컴파일러 (Compiler)

#### 주요 작업

* 문법 검사 (Syntax Checking)
* 변수, 함수의 선언/정의 확인
* 메모리 영역(Data, BSS 등) 설정
* 중간 코드(IR: Intermediate Representation) 생성 및 최적화

#### 컴파일러 구조 (3단계)

1. **프론트엔드 (Front-end)**

   * 언어에 맞는 문법 검사, 의미 분석
   * 소스 코드를 트리 형태로 표현 (GIMPLE 트리)
2. **미들엔드 (Middle-end)**

   * CPU 아키텍처와 무관한 일반적인 최적화 수행
   * 최적화된 중간 코드(IR)를 생성
3. **백엔드 (Back-end)**

   * CPU 아키텍처에 맞는 최적화 수행 (x86, ARM 등)
   * 어셈블리어 코드 생성

---

### 3. 어셈블리 (Assembly)

* **입력 파일**: 어셈블리어 파일 (\*.s)
* **출력 파일**: 오브젝트 파일 (\*.o)
* **도구**: 어셈블러 (Assembler)

#### 주요 작업

* 어셈블리어를 기계어로 변환
* 오브젝트 파일에 심볼 테이블, 재배치 정보 등을 포함

#### 오브젝트 파일 구조

* **헤더**: 파일 정보
* **텍스트 섹션**: 기계어 코드
* **데이터 섹션**: 전역/정적 변수
* **심볼 테이블**: 변수, 함수 정보
* **재배치 정보**: 메모리 주소 확정 전 정보

> 오브젝트 파일은 독립적으로 실행되지 않으며, 링킹 과정을 통해 실행 파일로 완성된다.

---

### 4. 링킹 (Linking)

* **입력 파일**: 오브젝트 파일 (*.o), 라이브러리 파일 (*.a, \*.so)
* **출력 파일**: 실행 파일 (예: a.out, .exe)
* **도구**: 링커 (Linker)

#### 주요 작업

* 여러 개의 오브젝트 파일과 라이브러리를 하나의 실행 파일로 통합
* **심볼 해석 (Symbol Resolution)**:
  변수, 함수 이름을 실제 메모리 주소로 매핑
* **재배치 (Relocation)**:
  오브젝트 파일에 기록된 주소 정보를 실행 파일 내에서 실제 주소로 변경

#### 링킹 방식

* **정적 링킹 (Static Linking)**:
  실행 파일에 모든 코드 포함 → 파일 크기 증가, 실행 시 외부 의존성 없음
* **동적 링킹 (Dynamic Linking)**:
  실행 시 필요한 라이브러리를 로드 → 실행 파일 크기 작고, 라이브러리 공유 가능

---

## 추가 개념 정리

* **툴체인 (Toolchain)**:
  전처리기, 컴파일러, 어셈블러, 링커까지 일련의 도구 모음.
* **어셈블리어 (Assembly Language)**:
  기계어 명령어를 사람이 읽을 수 있게 표현한 언어.
  CPU 아키텍처에 따라 다르며, 기계어와 1:1로 매칭된다.
* **심볼(Symbol)**:
  변수명, 함수명과 같이 코드에서 사용되는 식별자.

---

## 결론

* 컴파일은 단순히 "소스 코드 → 실행 파일"로 변환하는 과정이 아니라,
  전처리 → 컴파일 → 어셈블리 → 링킹이라는 복잡한 단계를 거쳐 이루어진다.
* 이 과정을 제대로 이해하면, 컴파일 에러, 링커 에러, 런타임 에러의 원인을 쉽게 파악할 수 있고,
  프로그램의 빌드 및 실행 원리를 더 깊이 이해할 수 있다.

---