# 04. 인자와 리턴값에 따른 함수의 4가지 종류

---

## 목표

* 함수 정의의 기본적인 형태와 문법을 이해한다.
* 인자와 리턴값 조합에 따른 함수 형태를 학습한다.

---

## 함수의 4가지 형태

| 리턴값 | 인자 | 예시                       |
| --- | -- | ------------------------ |
| 있음  | 있음 | `int sum(int a, int b);` |
| 없음  | 있음 | `void print(int x);`     |
| 있음  | 없음 | `int get_value();`       |
| 없음  | 없음 | `void init();`           |

---

## 1. 인자 O, 리턴값 O (가장 일반적인 형태)

```c
int sum(int a, int b) {
    return a + b;
}
```

* 주로 계산 결과 등을 반환할 때 사용한다.
* 인자의 개수가 많으면 배열이나 포인터로 처리할 수 있다.

```c
int sum_array(int arr[], int size) {
    int total = 0;
    for (int i = 0; i < size; i++) total += arr[i];
    return total;
}
```

---

## 2. 인자 O, 리턴값 X

```c
void print_message(const char* msg) {
    printf("%s\n", msg);
}
```

* 화면 출력, 파일 기록 등 결과를 반환할 필요 없이 부수 효과만 수행하는 경우 사용.

---

## 3. 인자 X, 리턴값 O

```c
int get_random() {
    return 42; // 임의의 값 반환 (예시)
}
```

* 주로 값을 생성하거나 내부 상태를 반환할 때 사용.
* 함수 호출 시 별도의 입력 없이 결과만 필요할 때 사용.

---

## 4. 인자 X, 리턴값 X

```c
void init_system() {
    // 시스템 초기화 코드
}
```

* 보통 시스템 설정, 하드웨어 초기화 등 수행 후 결과 반환이 필요 없는 경우 사용.

---

## 잘못된 함수 정의 예시

1. `void` 반환인데 값을 반환하려는 경우 (컴파일 에러)

```c
void func() {
    return 123; // 에러: void 함수는 값을 반환할 수 없음
}
```

2. 반환값 명시했으나 실제 값 반환하지 않음 (경고 발생)

```c
int func() {
    // return 문 없음 → 미정의 동작
}
```

3. 조건에 따라 반환값이 누락되는 경우 (경고 발생)

```c
int func(int flag) {
    if (flag) return 1;
    // flag가 0일 때는 반환 없음 → 미정의 동작
}
```

---

## 결론

* 함수 정의 시 리턴값과 인자를 정확히 정의하고 일관성 있게 작성해야 한다.
* `void` 함수는 절대 값을 반환하지 않으며, 리턴값이 명시된 함수는 반드시 값을 반환해야 한다.
* 실무에서는 대부분 "인자 O, 리턴값 O" 형태를 가장 많이 사용하고, 나머지는 필요에 따라 적절히 활용한다.

---

# 콜러와 콜리 (Caller vs Callee)

---

## 콜러와 콜리의 의미

* **Caller (콜러)**: 함수를 호출하는 주체 (호출자, 호출 함수)
* **Callee (콜리)**: 호출 당하는 함수 (피호출 함수)

예시에서 `mom` 함수가 `son` 함수를 호출할 때,

* `mom`: Caller (콜러)
* `son`: Callee (콜리)

```c
void son() {
    // 작업 내용
}

void mom() {
    son();  // mom이 son을 호출
}
```

C 프로그램은 주로 이러한 호출 관계로 함수들이 연결되어 있다.

예시:

```c
int main() {
    add();
    sub();
}

void add() { 
    // add 함수 내용 
}

void sub() { 
    // sub 함수 내용 
}
```

* `main` 함수는 `add`, `sub` 함수를 호출하므로 `main`은 Caller.
* `add`, `sub` 함수는 호출당하는 Callee.

**정리**: Caller가 Callee를 "직접" 호출하는 것이 중요하다. 호출 체인은 프로그램 흐름을 결정한다.

---

# 파라미터 vs 아규먼트 (parameter vs argument)

---

## 목표

파라미터와 아규먼트의 개념 차이를 명확하게 이해하자.

---

## 개념 정리

C 프로그램에서 함수 정의와 호출 시 다양한 용어들이 사용된다.
이 용어들은 엄밀히 구분되지만, 혼용되기도 한다.

| 구분    | 용어               | 설명           |
| ----- | ---------------- | ------------ |
| 함수 정의 | 파라미터 (parameter) | 함수에 정의된 변수   |
| 함수 호출 | 아규먼트 (argument)  | 함수 호출 시 전달 값 |

---

### 예시 코드

```c
int sum(int a, int b) {  // a, b → 파라미터 (parameter, 매개변수)
    return a + b;
}

int main() {
    int result = sum(3, 5);  // 3, 5 → 아규먼트 (argument, 전달인자)
    return 0;
}
```

* `a`, `b`: 매개변수(Parameter) — 함수 정의부에 선언된 변수.
* `3`, `5`: 전달인자(Argument) — 함수 호출 시 실제로 전달하는 값.

---

### 용어 비교

| 한글 표현   | 영어 표현            | 비고         |
| ------- | ---------------- | ---------- |
| 매개변수    | Parameter        | 함수 정의 시 사용 |
| 전달인자    | Argument         | 함수 호출 시 사용 |
| 형식 매개변수 | Formal Parameter | 정의 시 파라미터  |
| 실 매개변수  | Actual Argument  | 호출 시 아규먼트  |

---

### 핵심 정리

* **파라미터(Parameter)**: 변수 (variable)

  * 함수 내부에서 값을 받기 위해 사용됨.
* **아규먼트(Argument)**: 값 (value)

  * 함수 호출 시 실제로 전달되는 값.

---

결론:
"함수를 정의할 때는 파라미터를, 호출할 때는 아규먼트를 사용한다."
이렇게 구분해서 기억하면 된다.

---

# C 언어 함수에서 여러 값을 반환하는 방법

---

## 개요  
C 언어는 함수가 하나의 값만 반환할 수 있다. 
하지만 실무에서는 여러 값을 반환해야 하는 경우가 많기 때문에, 다양한 우회 방법을 사용한다. 
각 방법의 장단점을 살펴보고, 가장 안전하고 효율적인 방법을 알아본다.

---

## 잘못된 방법: 리턴을 여러 개 하려는 시도 (문법 오류)

```c
int int get_xy() { // 문법 오류
    int x = 11;
    int y = 22;
    return (x, y); // 잘못된 사용
}
````

* 리턴 타입에 여러 개의 자료형을 명시할 수 없다.
* return (x, y);는 마지막 값인 y만 반환한다.

---

## 전역 변수 사용 (권장하지 않음)

```c
int x = 0;
int y = 0;

void get_xy() {
    x = 33;
    y = 55;
}
```

* 구현은 쉽지만, 데이터 충돌, 코드 관리가 어렵고 디버깅이 복잡하다.

---

## 포인터(참조)를 이용한 반환 (권장)

```c
void get_xy(int* x, int* y) {
    *x = 11;
    *y = 22;
}
```

* 함수 호출 시 포인터를 넘겨 값을 직접 수정한다.

---

## 구조체를 사용한 반환

```c
typedef struct {
    int x;
    int y;
} point_t;

point_t get_xy() {
    point_t result = {1, 2};
    return result;
}
```

* 작은 구조체라면 유용하지만, 복사 비용이 발생하고 반복 호출 시 성능 저하가 생긴다.

---

## 지역 변수 참조 반환 (위험)

```c
point_t* get_point() {
    point_t tmp_pt = {11, 22};
    return &tmp_pt; // 댕글링 포인터 위험
}
```

* 함수 종료 시 지역 변수는 소멸하고, 반환된 포인터는 무효한 메모리 주소를 참조하게 된다.

---

## 구조체 참조를 인자로 받아 처리 (권장)

```c
void get_xy(point_t* point) {
    point->x = 33;
    point->y = 44;
}
```

* 포인터를 통해 값을 안전하게 전달하고, 큰 구조체 처리에도 효율적이다.

---

## 출력 매개변수 사용 (가장 권장되는 방법)

```c
void get_point(point_t* pt, int x, int y) {
    pt->x = x;
    pt->y = y;
}
```

* 호출자가 미리 메모리를 준비하고, 함수가 해당 메모리에 결과를 저장한다.
* C 표준 라이브러리 함수들도 대부분 이 방식을 사용한다.

---

## 출력 매개변수란?

* 값 객체(Value Object)는 데이터를 담는 구조체 객체이다.
* 출력 매개변수는 결과 값을 포인터를 통해 전달하는 인자를 의미한다.

```c
// 잘못된 방식
student_t calc_avg(student_t s); 

// 권장 방식
void calc_avg(student_t* dst, student_t* src);
```

---

## 복습 예제: 국어, 영어, 수학 점수 반환

### 전역 변수 (권장하지 않음)

```c
int kor, eng, math;
void score_subject() {
    kor = 100; eng = 90; math = 80;
}
```

### 포인터 사용

```c
void score_subject(int* kor, int* eng, int* math) {
    *kor = 100; *eng = 90; *math = 80;
}
```

### 구조체 리턴 (작은 구조체일 때 가능)

```c
typedef struct {
    int kor, eng, math;
} student_t;

student_t score_subject() {
    student_t s = {100, 90, 80};
    return s;
}
```

### 출력 매개변수 사용 (가장 권장)

```c
void score_subject(student_t* s, int kor, int eng, int math) {
    s->kor = kor; s->eng = eng; s->math = math;
}
```

---

## 결론

| 방법          | 안정성   | 효율성   | 권장 여부      |
| ----------- | ----- | ----- | ---------- |
| 전역 변수       | 낮음    | 낮음    | 권장하지 않음    |
| 포인터 사용      | 높음    | 높음    | 권장         |
| 구조체 리턴      | 높음    | 보통    | 작은 구조체만 권장 |
| 지역 변수 참조 리턴 | 매우 낮음 | 높음    | 절대 사용 금지   |
| 출력 매개변수     | 매우 높음 | 매우 높음 | 가장 권장      |

작은 구조체는 리턴해도 괜찮지만, 구조체 크기가 크거나 함수 호출이 빈번할 경우 반드시 출력 매개변수를 활용하는 것이 가장 효율적이다.

---