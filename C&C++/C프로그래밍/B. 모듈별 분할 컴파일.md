# 모듈별 분할 컴파일

---

## 개요

C 언어에서 프로젝트 규모가 커질수록 모듈화와 분할 컴파일의 중요성이 커진다.  
헤더파일과 소스파일의 역할, 분할 관리 방법, 그리고 주의사항에 대해 정리한다.

---

## 헤더파일을 여러 번 포함하는 것은 권장하지 않는다

- 의도적으로 같은 파일을 여러 번 include 하진 않지만, 대규모 프로젝트에서는 의도치 않게 중복 포함되는 경우가 많다.
- 중복 포함 시 컴파일러는 오류를 발생시키지 않지만, 관리상 바람직하지 않다.
- 이를 방지하기 위해 **헤더 가드**를 사용한다.

```c
#ifndef __HEADER_FILE_H__
#define __HEADER_FILE_H__

// 헤더 내용

#endif
````

* C99 이후에는 `#pragma once`도 사용 가능하다.

---

## 헤더파일은 반드시 필요한 것은 아니다

* 소규모 프로젝트에서는 모든 코드를 하나의 `.c` 파일에 작성해도 무방하다.
* 관리해야 할 파일 수가 많아지면, 오히려 개발 속도와 효율성이 저하된다.
* 그러나 프로젝트 규모가 커지면, 파일 분리와 모듈화는 필수적이다.

---

## 파일 구조를 어떻게 나눠야 하는지에 대한 정해진 기준은 없다

* 프로젝트의 성격, 개발 인원, 요구사항에 따라 파일 분리 방식은 달라진다.
* 유지보수와 협업, 가독성을 고려하여 상황에 맞게 유연하게 결정한다.

---

## include는 파일 내용을 그대로 가져오는 역할을 한다

* 파일 확장자에 관계없이 파일 내용을 그대로 복사해오는 전처리 작업이다.
* `.c`, `.h`, `.txt` 파일 모두 포함 가능하다.

---

## 헤더파일은 컴파일 대상이 아니라 전처리 대상이다

* 컴파일러는 `.h` 파일을 직접 컴파일하지 않는다.
* 전처리기가 include된 모든 파일을 병합한 후 `.i` 파일을 생성하고, 이 파일을 컴파일한다.

---

## 헤더파일에 함수 정의를 넣는 것은 매우 좋지 않다

* 헤더파일에는 함수 **선언**만 포함해야 한다.
* 함수 **정의**를 포함하면, 여러 파일에서 중복 정의로 인한 **링크 에러**가 발생할 수 있다.

```c
// 잘못된 cow.h 예시
#ifndef __COW_H__
#define __COW_H__

#include <stdio.h>

void moo() { // 함수 정의 (문제 발생)
    printf("음메\n");
}

#endif
```

* 올바른 방식

```c
// cow.h
#ifndef __COW_H__
#define __COW_H__

#include <stdio.h>

void moo(); // 함수 선언만 포함

#endif
```

```c
// cow.c
#include "cow.h"

void moo() {
    printf("음메\n");
}
```

---

## 사용자 정의 헤더파일과 헤더 가드

* 사용자 정의 헤더파일은 반드시 헤더 가드를 포함해야 한다.
* 헤더 가드가 없으면, 중복 포함 시 심각한 컴파일 또는 링크 오류가 발생할 수 있다.

---

## 정리

| 항목         | 소규모 프로젝트 | 대규모 프로젝트        |
| ---------- | -------- | --------------- |
| 헤더파일 사용    | 생략 가능    | 필수              |
| 파일 분리      | 필요 없음    | 적극적으로 분리        |
| include 관리 | 단순       | 체계적인 관리 필요      |
| 컴파일 속도     | 빠름       | 전처리와 분할 컴파일로 관리 |
| 코드 관리      | 쉬움       | 헤더 가드, 파일 분리 필수 |

* 프로젝트가 커질수록 파일 구조를 잘 나누고, 헤더 가드를 적극 활용하는 것이 유지보수와 협업에 유리하다.
* 헤더파일에는 함수 선언만 포함하고, 함수 정의는 반드시 `.c` 파일에 작성해야 한다.

---

# 함수 정의와 선언의 중복에 대한 이해

---

## 개요

C 언어에서 함수는 **정의**와 **선언**이라는 두 가지 형태로 사용된다.  
이 둘은 문법적 역할과 성격이 다르기 때문에, **정의는 중복되면 에러가 발생하지만, 선언은 여러 번 해도 문제없다**.

---

## 함수의 정의는 중복되면 안 된다

함수 정의란, 함수의 **실제 구현 내용**을 작성한 것이다.  
동일한 이름의 함수를 두 번 정의하면 컴파일 오류가 발생한다.

```c
#include <stdio.h>

void woof() { // 첫 번째 정의
    printf("멍멍\n");
}

void woof() { // 두 번째 정의 - 오류 발생
    printf("왈왈\n");
}

int main() {
    woof();
    return 0;
}
````

* 위 예시에서는 `woof` 함수가 두 번 정의되어 컴파일러가 에러를 출력한다.
* 에러 메시지: "function redefinition" 혹은 "multiple definition of function"

---

## 함수의 선언은 중복되어도 문제 없다

함수 선언은 **인터페이스만 알려주는 역할**을 한다.
즉, 함수가 어떤 이름이고 어떤 인자를 받고 어떤 값을 반환하는지만 명시한다.

```c
#include <stdio.h>

void meow();
void woof(); // 첫 번째 선언
void woof(); // 두 번째 선언
void woof(); // 세 번째 선언

void woof() {
    meow();
    printf("멍멍\n");
}

void meow() {
    woof();
    printf("야옹\n");
}

int main() {
    woof();
    meow();
    return 0;
}
```

* `woof` 함수가 여러 번 선언되었지만, **정의는 하나**이므로 문제가 없다.
* 선언은 중복되어도 컴파일러가 동일한 인터페이스로 인식하기 때문에 허용된다.

---

## 정리

| 구분    | 설명         | 중복 가능 여부    |
| ----- | ---------- | ----------- |
| 함수 정의 | 함수의 본문 구현  | 불가능 (에러 발생) |
| 함수 선언 | 함수의 형태만 알림 | 가능 (문제 없음)  |

* **함수는 하나의 정의만** 허용되며, 여러 선언은 허용된다.
* 헤더파일에서 동일한 함수를 여러 번 선언하는 경우가 생기므로, 선언의 중복은 C 언어에서 안전하고 허용된 방식이다.

---

## 실전에서의 활용

* 헤더파일에는 함수 선언만 포함하고, 여러 `.c` 파일에서 이 헤더를 include 하더라도 선언이 중복되어도 문제없다.
* 단, 함수 정의는 반드시 **한 파일에만 존재**해야 하며, 여러 파일에 중복 정의되면 링크 에러가 발생한다.

---

# 헤더 가드 작성 관례: `#pragma once` vs `#ifndef`

---

## 개요

헤더 가드는 헤더파일이 중복 포함되어 발생하는 오류를 방지하기 위한 전처리 지시문이다.  
작성 방식에는 대표적으로 두 가지가 있다:

1. 전통적인 방식: `#ifndef`, `#define`, `#endif`
2. Microsoft 확장 방식: `#pragma once`

---

## `#ifndef` 방식 (전통적, 표준 방식)

```c
#ifndef __HORSE_H__
#define __HORSE_H__

void neigh(); // 말, 히힝

#endif
````

### 장점

* 모든 C/C++ 컴파일러에서 지원
* 표준에 부합하는 방식
* 협업, 포팅, 크로스 플랫폼에 유리

### 작성 관례

* `__파일명_H__` 형식을 사용하는 것이 일반적
* 모두 대문자 사용
* 접두/접미에 언더스코어를 붙여서 다른 심볼과 충돌 방지

예시:

```c
#ifndef __COW_H__
#define __COW_H__

void moo();

#endif
```

---

## 잘못된 예시

```c
#ifndef ABC
#define ABC

void neigh(); // 어떤 헤더인지 알 수 없음

#endif
```

* `ABC`, `DEF` 같은 임의의 매크로명을 쓰는 것은 의미가 불분명하며 협업과 유지보수에 불리하다.

---

## `#pragma once` 방식 (비표준, 컴파일러 의존)

```c
#pragma once

void neigh(); // 말, 히힝
```

### 장점

* 코드가 짧고 간결하다
* 복잡한 매크로를 피할 수 있다

### 단점

* **표준이 아님**
* 모든 컴파일러에서 반드시 동작한다는 보장이 없다 (대부분은 지원하지만 예외가 존재할 수 있음)

---

## 권장 방식

| 방식             | 호환성              | 유지보수 | 추천 여부         |
| -------------- | ---------------- | ---- | ------------- |
| `#ifndef`      | 매우 높음            | 명확함  | 권장            |
| `#pragma once` | 보통 (실제로는 널리 지원됨) | 간결함  | 비표준이라 권장하지 않음 |

* 크로스 플랫폼, 협업, 코드 공유 등을 고려할 때는 **`#ifndef` 방식**을 사용하는 것이 좋다.

---

## 결론

* 헤더 가드는 반드시 작성해야 하며, 가능한 한 **표준 방식인 `#ifndef`** 방식을 사용할 것.
* 매크로명은 **파일명을 대문자로 바꾸고 앞뒤로 언더스코어를 붙여 작성**하는 것이 관례다.
* `#pragma once`는 실무에서도 자주 쓰이긴 하지만, **비표준이므로 공식적인 코드에서는 피하는 것이 좋다.**

---

# 헤더 가드를 적용해도 문제가 생길 수 있다

---

## 개요

헤더 가드는 중복 포함을 방지하는 매우 유용한 기법이다.  
그러나 **서로가 서로를 포함하는 구조**에서 의존 관계가 얽히면,  
헤더 가드만으로는 해결할 수 없는 **전방 선언 문제**가 발생할 수 있다.

---

## 문제 상황

세 개의 파일이 있다고 가정하자:

### main.c

```c
#include "horse.h"
#include "donkey.h"

int main() {
    neigh();
    return 0;
}
````

### horse.h

```c
#ifndef __HORSE_H__
#define __HORSE_H__

#include "donkey.h"

void cluck() { // 말 발굽 소리
}

void neigh() { // 말 울음
    hee_haw();
}

#endif
```

### donkey.h

```c
#ifndef __DONKEY_H__
#define __DONKEY_H__

#include "horse.h"

// void cluck(); // 이 선언이 없으면 에러 발생

void hee_haw() { // 당나귀 울음
    cluck(); // 여기서 컴파일 에러 발생
}

#endif
```

---

## 발생하는 문제

* `donkey.h`에서 `cluck()`을 호출하고 싶은데, 이 시점에서는 `cluck()`이 아직 정의되어 있지 않다.
* `cluck()`은 `horse.h`의 아래쪽에서 정의되므로, **정의 순서상 접근할 수 없다**.
* 헤더 가드 때문에 `horse.h`가 재포함되지 않기 때문에, `cluck()`의 내용이 누락된 채 처리된다.
* 결과적으로 `hee_haw()`에서 `cluck()` 호출 시 **컴파일 에러 발생**.

---

## 왜 헤더 가드로도 해결되지 않는가?

* `horse.h` → `donkey.h` → `horse.h` 로 다시 진입하지만,
* 헤더 가드로 인해 두 번째 `horse.h`는 무시된다.
* 이로 인해 `donkey.h` 입장에서 `cluck()`이 보이지 않게 된다.

---

## 해결 방법 1: 전방 선언 추가

```c
void cluck(); // 전방 선언

void hee_haw() {
    cluck(); // 이제 문제 없음
}
```

* `donkey.h` 상단에서 `cluck()` 함수의 프로토타입을 선언해주면 문제는 해결된다.
* 그러나 이 방식은 **유지보수에 매우 불리하다.**

---

## 왜 전방 선언이 좋지 않은가?

* 의존성 관리가 어려워진다.
* 호출하는 모든 함수에 대해 일일이 선언을 추가해야 한다.
* 만약 함수가 10개, 20개면 모두 선언해야 하므로 코드가 복잡해진다.

예를 들어, `printf`를 사용하기 위해 아래와 같은 선언을 매번 작성해야 한다면 매우 비효율적이다:

```c
// 비효율적인 방식
int printf(const char* format, ...);
printf("Hello\n");
```

---

## 더 좋은 방법: 의존 관계 재구성

* 헤더파일 간 **상호 참조를 피하도록 구조를 재조정**한다.
* 필요한 함수 선언만 별도의 중립 헤더파일로 분리하거나,
* 함수 정의를 `.c` 파일에 넣고, 함수 원형만 `.h` 파일에 분리한다.

예)

```c
// horse.h
#ifndef __HORSE_H__
#define __HORSE_H__

void cluck();
void neigh();

#endif

// horse.c
#include "horse.h"
#include "donkey.h"

void cluck() {
    printf("따그닥\n");
}

void neigh() {
    hee_haw();
}
```

이렇게 하면 헤더 순환참조와 정의 순서 문제를 깔끔하게 방지할 수 있다.

---

## 결론

* 헤더 가드는 중복 포함만 막아줄 뿐, **정의 순서 문제는 해결하지 못한다**.
* 서로 참조하는 헤더가 있을 때는 전방 선언만으로는 한계가 있으므로,
  **모듈 의존성을 재설계**하는 것이 바람직하다.
* 함수 정의는 `.c` 파일에 작성하고, `.h` 파일에는 선언만 작성하는 것이 가장 안전한 구조다.

---
