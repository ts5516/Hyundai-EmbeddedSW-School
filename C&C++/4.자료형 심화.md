# char, signed char, unsigned char은 다르다!

---

## 목표

- char, signed char, unsigned char의 차이점을 이해한다.

---

## int와 signed int는 동일하다

- `int`는 기본적으로 `signed int`와 동일하다.
- 즉, 다음 두 선언은 완전히 같다.
```c
int a;
signed int b;
````

* 따라서, 정수형에서는 부호 유무에 대해 명확하게 정의되어 있다.

---

## char과 signed char은 다르다

* char에도 부호가 있는지 여부가 존재한다.
* 선언 방식:

  * `signed char` : 부호 있는 8비트 정수
  * `unsigned char` : 부호 없는 8비트 정수
  * `char` : 부호 여부가 명확하지 않음 (컴파일러, 플랫폼에 따라 다름)

---

## 왜 char은 부호가 명확하지 않을까?

* C 표준에서는 `char`의 부호 여부를 명확히 정의하지 않음.
* 이유:

  * 문자 데이터 저장 목적으로 설계된 타입.
  * ASCII 코드(0\~127)만 사용할 경우 부호 유무는 중요하지 않음.
  * 확장 ASCII(128\~255)까지 사용하면 부호에 따라 표현 가능한 값이 달라짐.
* 결과적으로 컴파일러 구현에 따라 `char`는 `signed char` 또는 `unsigned char`로 동작할 수 있다.

---

## 컴파일러별 예시

| 컴파일러      | char 기본 부호 |
| --------- | ---------- |
| GCC (x86) | signed     |
| ARM       | unsigned   |
| MSVC      | signed     |

* 따라서 이식성 있는 코드를 작성할 때는 `signed char` 또는 `unsigned char`를 명시적으로 사용해야 한다.

---

## char 형이 시스템 종속적인 이유

* C/C++ 표준은 char의 부호 여부를 플랫폼에 맞게 유연하게 처리하도록 설계.
* 자세한 내용:
  [Why is char implementation dependent? (StackOverflow)](https://stackoverflow.com/questions/57898617/in-the-c11-standard-why-leave-the-char-type-implementation-dependent)

---

# define vs const 어떤 것을 써야 할까?

---

## 목표

- 상수를 정의할 때 define과 const 중 어떤 것이 더 좋은지 알아본다.

---

## 결론: const를 추천

- const는 타입이 명확하고, 컴파일러가 타입 오류를 검출할 수 있다.
- 디버깅이 가능하며, 스코프 조정으로 불필요한 전역 치환을 방지할 수 있다.
- define은 단순 치환으로, 타입 검사가 되지 않고 디버깅이 어렵다.

---

## const 사용 예시

```c
const double PAI = 3.141592;
static const double PAI = 3.141592; // 스코프 제한
````

* static을 사용하면 링커 충돌 방지.

---

## define 사용 예시

```c
#define PAI 3.141592
```

* 타입 정보 없음, 단순 치환.

---

## 두 방식 비교

| 구분     | #define | const         |
| ------ | ------- | ------------- |
| 처리 시점  | 전처리기    | 컴파일러          |
| 타입 체크  | 불가      | 가능            |
| 디버깅    | 불편      | 편리 (심볼 추적 가능) |
| 스코프    | 전역      | 제한 가능         |
| 메모리 사용 | 없음 (치환) | 상수로 메모리 사용    |

---

## 주의사항

* const는 헤더 파일에 직접 선언하지 말고, static 또는 extern을 사용해야 한다.

```c
// 헤더 파일
extern const double PAI;

// C 파일
const double PAI = 3.141592;
```

* static const 사용 시 각 C 파일마다 복사본이 생성된다.

---

## const 디버깅 필요성

* 상수 값이 환경별로 다를 수 있어, 디버깅 시 값을 확인하는 것이 중요하다.
* define은 값 확인 불가, const는 디버깅 도구로 직접 확인 가능.

---

# 리틀 엔디안, 빅 엔디안이란? (Little Endian vs Big Endian)

---

## 목표

- 리틀 엔디안, 빅 엔디안의 개념과 차이를 이해한다.

---

## 문자 방향성과 읽기 방향성

- LTR (Left to Right): 영어, 프랑스어, 한국어
- RTL (Right to Left): 아랍어, 히브리어, 페르시아어

---

## 12 34 56을 어떻게 저장할까?

- 바이트 오더(Byte Order)에 따라 메모리에 저장되는 방식이 다르다.
- 초기 컴퓨터는 바이트 오더에 대한 규칙이 없었고, CPU 제조사에 따라 달랐다.

---

## 빅 엔디안, 리틀 엔디안이란?

- 엔디안(Endian)은 데이터를 메모리에 어떤 순서로 저장할지를 정의한 것이다.

| 방식       | 저장 순서 (예: 0x12345678) |
|------------|----------------------------|
| 빅 엔디안  | 12 34 56 78                |
| 리틀 엔디안| 78 56 34 12                |

---

## 엔디안 관련 질문

- 비트 오더는 일반적으로 존재하지 않는다. 바이트 순서만 다루며, 바이트 내부 비트 순서는 변하지 않는다.
- 미들 엔디안: 빅 엔디안, 리틀 엔디안 혼합형. ARM 프로세서는 둘 다 지원한다.

---

## 빅 엔디안 vs 리틀 엔디안

### 빅 엔디안

- 사람이 읽는 방식과 동일 (가장 큰 자리부터).
- 네트워크 프로토콜(TCP/IP) 표준으로 사용.

### 리틀 엔디안

- 하드웨어 설계가 단순하고 연산 효율성 높음.
- 현대 CPU(인텔, AMD 등)의 표준.
- 부분 데이터 접근 용이.

---

## 엔디안을 배우는 이유

- 네트워크 통신 등 이기종 시스템 간 데이터 교환 시 문제가 발생할 수 있기 때문이다.
- 예: 송신 시스템은 빅 엔디안, 수신 시스템은 리틀 엔디안이면 데이터 해석에 문제가 발생.

---

## 요약

| 구분       | 빅 엔디안         | 리틀 엔디안       |
|-------------|-------------------|-------------------|
| 장점        | 직관적, 네트워크 표준 | 연산 효율성, 현대 CPU 표준 |
| 단점        | 연산 효율 떨어짐    | 사람이 읽기 어려움    |
| 사용 분야   | 네트워크, 특수 시스템 | 범용 컴퓨팅 환경     |

---

# 음수 표현법: 2의 보수 체계 (Two’s Complement)

---

## 목표

- 보수의 개념과 2의 보수 체계를 이해한다.

---

## 2의 보수 방식

- 컴퓨터에서 음수를 표현할 때 사용되는 표준 방식.
- 예시 (4비트 기준):

```
0111 → 7
0000 → 0
1111 → -1
1000 → -8
```

---

## 부호-크기 방식과 2의 보수 방식 비교

| 구분         | 2의 보수    | 부호-크기 방식 |
|---------------|--------------|----------------|
| 연산 처리      | 가산기 1개로 단순 처리 | 부호 확인, 절댓값 처리 필요 |
| 0 표현        | 0 하나만 존재  | +0, -0 중복 존재 |
| 오버플로우 감지 | 간단          | 복잡              |
| 하드웨어 구현  | 간단          | 복잡              |

---

## 보수란?

- 어떤 수에 보수를 더했을 때 진법의 밑수(r)가 되도록 만드는 수.
- 10진법에서 3의 10의 보수는 7 (3 + 7 = 10).

---

## 보수의 용도

- 음수 표현 및 뺄셈을 덧셈으로 처리할 때 사용.

```
3 - 2 = 3 + (-2)
```

- -2는 2의 보수를 이용해 표현.

---

## 보수 종류

- 1의 보수: 비트를 반전.
- 2의 보수: 1의 보수에 1을 더함 (일반적으로 사용).

---

## 2의 보수 수학적 정의

```
r의 보수 = r^n - N (N ≠ 0)
```

- r: 진법 (2진법일 경우 2)
- n: 자리수
- N: 변환할 수

---

## 2의 보수 계산 예제 (4비트 기준)

1. 3의 2의 보수  
- 3 = 0b0011  
- 2^4 - 3 = 13 = 0b1101  
- 검증: 0b0011 + 0b1101 = 0b0000 (올림 비트 버림)

2. -1의 2의 보수 (32비트 기준)  
- 2^32 - 1 = 4,294,967,295 = 0xFFFFFFFF  

---

## 2의 보수 계산 공식

1. 양수로 변환  
2. 1의 보수 (비트 반전)  
3. +1 더하기  
4. 16진수로 변환

```
예시: -1204

1. 1204 → 0x000004B4  
2. 1의 보수 → 0xFFFFFB4B  
3. +1 → 0xFFFFFB4C  
4. 결과: 0xFFFFFB4C
```
---

# lvalue vs rvalue (좌변값 vs 우변값) 1

---

## 목표

- lvalue와 rvalue의 개념을 이해한다.

---

## 기본 개념

- lvalue: 대입 연산자 왼쪽에 올 수 있는 값 (변수처럼 메모리 주소를 가진 값).
- rvalue: 대입 연산자 오른쪽에 올 수 있는 값 (임시 값, 리터럴 값 등).

---

## 예시 코드

```c
int a;
a = 3;      // 가능: a는 lvalue, 3은 rvalue

0x1234 = 0x1234; // 불가능: 리터럴은 lvalue가 될 수 없음
````

---

## 고전적 정의

* lvalue: left value → 현재는 locator value (메모리 위치를 갖는 값).
* rvalue: right value → 값 그 자체, 임시로 존재.

```c
int a = 11;   // a: lvalue, 11: rvalue
```

---

## 예제에서 lvalue, rvalue 구분

```c
int a;
0x11 = 0x22; // Error: 리터럴은 lvalue가 될 수 없음
a = 3;       // OK: a는 lvalue, 3은 rvalue
3 = a;       // Error: 리터럴은 lvalue가 될 수 없음
```

---

## lvalue에 변수 외 다른 것도 올 수 있다

```c
int arr[3] = {0, 0, 0};
arr[2] = 33;   // OK: arr[2]는 lvalue

int a = 3;
int* pa = &a;  // OK: 포인터를 통한 간접 접근도 lvalue
```

---

## 정리

* lvalue: 메모리 주소를 가지고, 값을 저장할 수 있다.
* rvalue: 일시적인 값으로, 대입 대상이 될 수 없다.
* lvalue 오류는 값을 저장할 수 없는 리터럴에 값을 대입할 때 발생한다.

---

# lvalue vs rvalue (좌변값 vs 우변값) 2

---

## 목표

- lvalue와 rvalue의 개념을 더 깊이 이해한다.

---

## lvalue가 메모리 영역이면 다 되는 건 아니다

예시 코드:

```c
#include <stdio.h>

int main(void) {
    int x = 3;
    const int y = x;
    int z = x + y;
}
````

* y는 메모리에 존재하지만 const로 인해 값 변경 불가 → modifiable lvalue가 아님.

---

## 현대적 정의

* left value → locator value (메모리 위치를 참조하는 값)

* right value → value of an expression (표현식의 값)

* 예전 left value 개념을 **modifiable lvalue**로 구분.

---

## lvalue가 될 수 없는 경우

1. 배열 이름

   ```c
   int arr[3] = {};
   arr = 0; // 불가능, 배열 이름은 포인터로 암시적 변환되지만 lvalue 아님
   ```

2. 불완전한 타입 (incomplete type)
   예: 크기가 정의되지 않은 `void*` 등

3. const 한정자가 붙은 변수

   ```c
   const int a = 3;
   a = 4; // 에러, const 변수는 값 변경 불가
   ```

4. const 멤버를 포함하는 구조체나 공용체

---

## 대상체 (Object)란?

* **Object**: 이름이 붙은 저장 공간 영역.
* **lvalue**: 특정 object를 참조하는 표현식.

표준 정의:

* "An object is a named region of storage."
* "An lvalue is an expression referring to an object."

---

## lvalue to rvalue Conversion

* lvalue가 rvalue 위치에 올 수 있으며, 이때 자동 변환 발생.

```c
int a = 11;
int b = 22;
b = a; // a는 원래 lvalue, rvalue로 변환되어 사용됨
```

---

## 결론

* **lvalue**: 사라지지 않는 값, 메모리 공간에 이름이 있는 변수.
* **rvalue**: 일시적인 값, 표현식 이후 사라지는 값 (임시 변수, 리터럴).

---