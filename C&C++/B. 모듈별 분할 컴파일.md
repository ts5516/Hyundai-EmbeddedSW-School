# 모듈별 분할 컴파일

---

## 개요

C 언어에서 프로젝트 규모가 커질수록 모듈화와 분할 컴파일의 중요성이 커진다.  
헤더파일과 소스파일의 역할, 분할 관리 방법, 그리고 주의사항에 대해 정리한다.

---

## 헤더파일을 여러 번 포함하는 것은 권장하지 않는다

- 의도적으로 같은 파일을 여러 번 include 하진 않지만, 대규모 프로젝트에서는 의도치 않게 중복 포함되는 경우가 많다.
- 중복 포함 시 컴파일러는 오류를 발생시키지 않지만, 관리상 바람직하지 않다.
- 이를 방지하기 위해 **헤더 가드**를 사용한다.

```c
#ifndef __HEADER_FILE_H__
#define __HEADER_FILE_H__

// 헤더 내용

#endif
````

* C99 이후에는 `#pragma once`도 사용 가능하다.

---

## 헤더파일은 반드시 필요한 것은 아니다

* 소규모 프로젝트에서는 모든 코드를 하나의 `.c` 파일에 작성해도 무방하다.
* 관리해야 할 파일 수가 많아지면, 오히려 개발 속도와 효율성이 저하된다.
* 그러나 프로젝트 규모가 커지면, 파일 분리와 모듈화는 필수적이다.

---

## 파일 구조를 어떻게 나눠야 하는지에 대한 정해진 기준은 없다

* 프로젝트의 성격, 개발 인원, 요구사항에 따라 파일 분리 방식은 달라진다.
* 유지보수와 협업, 가독성을 고려하여 상황에 맞게 유연하게 결정한다.

---

## include는 파일 내용을 그대로 가져오는 역할을 한다

* 파일 확장자에 관계없이 파일 내용을 그대로 복사해오는 전처리 작업이다.
* `.c`, `.h`, `.txt` 파일 모두 포함 가능하다.

---

## 헤더파일은 컴파일 대상이 아니라 전처리 대상이다

* 컴파일러는 `.h` 파일을 직접 컴파일하지 않는다.
* 전처리기가 include된 모든 파일을 병합한 후 `.i` 파일을 생성하고, 이 파일을 컴파일한다.

---

## 헤더파일에 함수 정의를 넣는 것은 매우 좋지 않다

* 헤더파일에는 함수 **선언**만 포함해야 한다.
* 함수 **정의**를 포함하면, 여러 파일에서 중복 정의로 인한 **링크 에러**가 발생할 수 있다.

```c
// 잘못된 cow.h 예시
#ifndef __COW_H__
#define __COW_H__

#include <stdio.h>

void moo() { // 함수 정의 (문제 발생)
    printf("음메\n");
}

#endif
```

* 올바른 방식

```c
// cow.h
#ifndef __COW_H__
#define __COW_H__

#include <stdio.h>

void moo(); // 함수 선언만 포함

#endif
```

```c
// cow.c
#include "cow.h"

void moo() {
    printf("음메\n");
}
```

---

## 사용자 정의 헤더파일과 헤더 가드

* 사용자 정의 헤더파일은 반드시 헤더 가드를 포함해야 한다.
* 헤더 가드가 없으면, 중복 포함 시 심각한 컴파일 또는 링크 오류가 발생할 수 있다.

---

## 정리

| 항목         | 소규모 프로젝트 | 대규모 프로젝트        |
| ---------- | -------- | --------------- |
| 헤더파일 사용    | 생략 가능    | 필수              |
| 파일 분리      | 필요 없음    | 적극적으로 분리        |
| include 관리 | 단순       | 체계적인 관리 필요      |
| 컴파일 속도     | 빠름       | 전처리와 분할 컴파일로 관리 |
| 코드 관리      | 쉬움       | 헤더 가드, 파일 분리 필수 |

* 프로젝트가 커질수록 파일 구조를 잘 나누고, 헤더 가드를 적극 활용하는 것이 유지보수와 협업에 유리하다.
* 헤더파일에는 함수 선언만 포함하고, 함수 정의는 반드시 `.c` 파일에 작성해야 한다.